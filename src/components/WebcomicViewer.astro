---
import type { ImageMetadata } from 'astro'
import { Image } from 'astro:assets'

interface Props {
  images: ImageMetadata[]
  title: string
  description: string
  immersive?: boolean
}

const { images, title, immersive = true } = Astro.props
---

<div
  class:list={[
    'relative group select-none rounded-lg overscroll-contain transition-all duration-500',
    immersive && 'webcomic-viewer-immersive',
  ]}
  role="region"
  aria-label={`${title} webcomic viewer`}
  tabindex="0"
>
  <div
    id="webcomic-container"
    class="relative overflow-hidden rounded-lg bg-neutral touch-pan-y overscroll-contain ring-0 group-focus-within:ring-2 group-hover:ring-2 ring-primary transition-all duration-200 max-h-[85vh]"
    role="presentation"
  >
    <div
      id="webcomic-slider"
      class="flex touch-pan-x transition-transform duration-300 ease-in-out h-full"
      role="list"
    >
      {images.map((image, index) => (
        <div
          class="w-full flex-shrink-0 transition-opacity duration-300 h-full flex items-center justify-center"
          data-page={index + 1}
          role="listitem"
          aria-label={`Page ${index + 1}`}
        >
          <Image
            src={image}
            alt={`${title} - Page ${index + 1}`}
            class="w-full h-full object-contain"
            loading={index <= 1 ? 'eager' : 'lazy'}
          />
        </div>
      ))}
    </div>

    <div
      class="absolute inset-0 flex items-center justify-between opacity-0 group-hover:opacity-100 group-focus-within:opacity-100 transition-opacity duration-200"
      role="group"
      aria-label="Page navigation"
    >
      <button
        type="button"
        id="prev-page"
        class="m-4 bg-neutral/80 hover:bg-neutral hover:text-primary rounded-xl border border-base-content/50 backdrop-blur-sm transition-colors duration-200 ease-in-out w-12 h-12 flex items-center justify-center text-xl focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2"
        disabled={true}
        aria-label="Previous page"
      >
        ←
      </button>

      <button
        type="button"
        id="next-page"
        class="m-4 bg-neutral/80 hover:bg-neutral hover:text-primary rounded-xl border border-base-content/50 backdrop-blur-sm transition-colors duration-200 ease-in-out w-12 h-12 flex items-center justify-center text-xl focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2"
        disabled={images.length <= 1}
        aria-label="Next page"
      >
        →
      </button>
    </div>
  </div>

  <div
    class="mt-4 text-center text-sm"
    role="status"
    aria-live="polite"
  >
    Page <span id="current-page">1</span> of {images.length}
  </div>
</div>

<style>
  .webcomic-viewer-immersive:focus-within {
    position: relative;
    z-index: 10;
  }

  /* Add styles for better image fitting */
  #webcomic-container {
    min-height: min(85vh, 1000px);
  }

  @media (max-width: 768px) {
    #webcomic-container {
      min-height: min(90vh, 800px);
    }
  }
</style>

<script>
function initWebcomicViewer() {
  const container = document.getElementById('webcomic-container')
  const slider = document.getElementById('webcomic-slider')
  const prevBtn = document.getElementById('prev-page') as HTMLButtonElement | null
  const nextBtn = document.getElementById('next-page') as HTMLButtonElement | null
  const currentPageEl = document.getElementById('current-page')
  const pages = slider?.querySelectorAll('[data-page]')
  const viewer = container?.parentElement

  if (!container || !slider || !prevBtn || !nextBtn || !currentPageEl || !pages || !viewer)
    return

  let currentPage = 1
  const totalPages = pages.length
  let isFocused = false
  let isHovering = false

  function updatePage(newPage: number) {
    if (!slider || !currentPageEl || !prevBtn || !nextBtn || !pages)
      return

    currentPage = newPage
    currentPageEl.textContent = currentPage.toString()

    prevBtn.disabled = currentPage === 1
    nextBtn.disabled = currentPage === totalPages

    slider.style.transform = `translateX(${(currentPage - 1) * -100}%)`

    Array.from(pages).forEach((page, index) => {
      const isVisible = Math.abs(index + 1 - currentPage) <= 1
      ;(page as HTMLElement).style.opacity = isVisible ? '1' : '0'
    })
  }

  let startX = 0
  let currentX = 0
  let isDragging = false

  function handleDragStart(e: MouseEvent | TouchEvent) {
    if (!slider)
      return

    e.preventDefault()
    isDragging = true
    startX = 'touches' in e ? e.touches[0].pageX : e.pageX
    currentX = startX

    slider.style.transition = 'none'
    slider.style.cursor = 'grabbing'
  }

  function handleDragMove(e: MouseEvent | TouchEvent) {
    if (!isDragging || !slider)
      return

    const x = 'touches' in e ? e.touches[0].pageX : e.pageX
    const diff = x - startX
    currentX = x

    const offset = ((currentPage - 1) * -100) + (diff / slider.offsetWidth * 100)
    slider.style.transform = `translateX(${offset}%)`
  }

  function handleDragEnd() {
    if (!isDragging || !slider)
      return
    isDragging = false

    slider.style.transition = 'transform 300ms ease-in-out'
    slider.style.cursor = 'grab'

    const diff = currentX - startX
    const threshold = window.innerWidth * 0.15

    if (Math.abs(diff) > threshold) {
      if (diff > 0 && currentPage > 1)
        updatePage(currentPage - 1)
      else if (diff < 0 && currentPage < totalPages)
        updatePage(currentPage + 1)
      else
        updatePage(currentPage)
    }
    else {
      updatePage(currentPage)
    }
  }

  function handleWheel(e: WheelEvent) {
    if (!isHovering && !isFocused)
      return

    // prevent browser back/forward navigation more aggressively
    if (Math.abs(e.deltaX) > Math.abs(e.deltaY)) {
      e.preventDefault()
      e.stopPropagation()

      if (e.deltaX > 0 && currentPage < totalPages)
        updatePage(currentPage + 1)
      else if (e.deltaX < 0 && currentPage > 1)
        updatePage(currentPage - 1)

      return false
    }
  }

  function toggleImmersiveMode(active: boolean) {
    if (!viewer?.classList.contains('webcomic-viewer-immersive'))
      return

    document.body.classList.toggle('webcomic-immersive-mode', active)
  }

  function handleFocus() {
    isFocused = true
    toggleImmersiveMode(true)
  }

  function handleBlur() {
    isFocused = false
    toggleImmersiveMode(false)
  }

  function handleMouseEnter() {
    isHovering = true
    toggleImmersiveMode(true)
  }

  function handleMouseLeave() {
    isHovering = false
    toggleImmersiveMode(false)
  }

  // Event listeners
  prevBtn.addEventListener('click', () => {
    if (currentPage > 1)
      updatePage(currentPage - 1)
  })

  nextBtn.addEventListener('click', () => {
    if (currentPage < totalPages)
      updatePage(currentPage + 1)
  })

  document.addEventListener('keydown', (e) => {
    if (!isFocused && !isHovering)
      return

    if (e.key === 'ArrowLeft' && currentPage > 1)
      updatePage(currentPage - 1)
    else if (e.key === 'ArrowRight' && currentPage < totalPages)
      updatePage(currentPage + 1)
  })

  container.addEventListener('selectstart', e => e.preventDefault())
  container.addEventListener('mousedown', handleDragStart, { passive: false })
  container.addEventListener('touchstart', handleDragStart, { passive: false })

  window.addEventListener('mousemove', handleDragMove)
  window.addEventListener('touchmove', handleDragMove)
  window.addEventListener('mouseup', handleDragEnd)
  window.addEventListener('touchend', handleDragEnd)
  window.addEventListener('wheel', handleWheel, { passive: false, capture: true })

  viewer.addEventListener('focus', handleFocus)
  viewer.addEventListener('blur', handleBlur)
  viewer.addEventListener('mouseenter', handleMouseEnter)
  viewer.addEventListener('mouseleave', handleMouseLeave)

  // Cleanup function that returns void explicitly
  const cleanup = () => {
    container.removeEventListener('selectstart', e => e.preventDefault())
    container.removeEventListener('mousedown', handleDragStart)
    container.removeEventListener('touchstart', handleDragStart)

    window.removeEventListener('mousemove', handleDragMove)
    window.removeEventListener('touchmove', handleDragMove)
    window.removeEventListener('mouseup', handleDragEnd)
    window.removeEventListener('touchend', handleDragEnd)
    window.removeEventListener('wheel', handleWheel)

    viewer.removeEventListener('focus', handleFocus)
    viewer.removeEventListener('blur', handleBlur)
    viewer.removeEventListener('mouseenter', handleMouseEnter)
    viewer.removeEventListener('mouseleave', handleMouseLeave)
  }

  return cleanup
}

// Initialize with proper typing for the cleanup function
document.addEventListener('astro:page-load', () => {
  const cleanup = initWebcomicViewer()
  if (cleanup) {
    document.addEventListener('astro:before-swap', () => cleanup())
  }
})
</script>
